import { Request, Response } from 'express';
import { getVault } from '../../secure-vault';

export class VaultController {
  async getSecrets(req: Request, res: Response) {
    try {
      const vault = getVault();
      const secrets = await vault.listSecrets();
      const secretData = [];
      
      for (const key of secrets) {
        const value = await vault.getSecret(key);
        secretData.push({
          key,
          value: value || '',
          masked: this.maskValue(value),
          hasValue: !!value
        });
      }
      
      res.json({ success: true, secrets: secretData });
    } catch (error) {
      res.status(500).json({ success: false, error: error instanceof Error ? error.message : "Unknown error" });
    }
  }

  async setSecret(req: Request, res: Response) {
    try {
      const { key, value, encrypted = true } = req.body;
      
      if (!key || !value) {
        return res.status(400).json({ success: false, error: 'Key and value are required' });
      }
      
      const vault = getVault();
      await vault.setSecret(key, value, encrypted);
      
      res.json({ success: true, message: 'Secret saved successfully' });
    } catch (error) {
      res.status(500).json({ success: false, error: error instanceof Error ? error.message : "Unknown error" });
    }
  }

  async deleteSecret(req: Request, res: Response) {
    try {
      const { key } = req.params;
      const vault = getVault();
      const removed = await vault.removeSecret(key);
      
      if (removed) {
        res.json({ success: true, message: 'Secret removed successfully' });
      } else {
        res.status(404).json({ success: false, error: 'Secret not found' });
      }
    } catch (error) {
      res.status(500).json({ success: false, error: error instanceof Error ? error.message : "Unknown error" });
    }
  }

  async importEnv(req: Request, res: Response) {
    try {
      const { envContent } = req.body;
      
      if (!envContent) {
        return res.status(400).json({ success: false, error: 'Environment content is required' });
      }
      
      const vault = getVault();
      const imported = await this.parseAndImportEnv(vault, envContent);
      
      res.json({ success: true, message: `Imported ${imported} secrets` });
    } catch (error) {
      res.status(500).json({ success: false, error: error instanceof Error ? error.message : "Unknown error" });
    }
  }

  async exportEnv(req: Request, res: Response) {
    try {
      const vault = getVault();
      const secrets = await vault.listSecrets();
      
      let envContent = '# PersonaRAG Bridge Environment Configuration\n';
      envContent += '# Generated by vault web interface\n\n';
      
      for (const secretKey of secrets) {
        const value = await vault.getSecret(secretKey);
        if (value) {
          envContent += `${secretKey}=${value}\n`;
        }
      }
      
      res.setHeader('Content-Type', 'text/plain');
      res.setHeader('Content-Disposition', 'attachment; filename="persona-rag.env"');
      res.send(envContent);
    } catch (error) {
      res.status(500).json({ success: false, error: error instanceof Error ? error.message : "Unknown error" });
    }
  }

  async getStatus(req: Request, res: Response) {
    try {
      const vault = getVault();
      const secrets = await vault.listSecrets();
      const validation = await vault.validateSecurity();
      const status = vault.getStatus();
      
      res.json({
        success: true,
        status: {
          initialized: status.initialized,
          secretCount: secrets.length,
          vaultPath: status.vaultPath,
          securityValid: validation.valid,
          issues: validation.issues
        }
      });
    } catch (error) {
      res.status(500).json({ success: false, error: error instanceof Error ? error.message : "Unknown error" });
    }
  }

  private maskValue(value: string | null): string {
    if (!value || value.length <= 8) return value || '';
    return value.substring(0, 4) + '*'.repeat(value.length - 8) + value.substring(value.length - 4);
  }

  private async parseAndImportEnv(vault: any, envContent: string): Promise<number> {
    const lines = envContent.split('\n').filter(line => 
      line.trim() && !line.startsWith('#') && line.includes('=')
    );
    
    let imported = 0;
    
    for (const line of lines) {
      const [key, ...valueParts] = line.split('=');
      const value = valueParts.join('=');
      
      if (!key || !value) continue;
      
      const trimmedKey = key.trim();
      const trimmedValue = value.trim();
      
      await vault.setSecret(trimmedKey, trimmedValue);
      imported++;
    }
    
    return imported;
  }
} 